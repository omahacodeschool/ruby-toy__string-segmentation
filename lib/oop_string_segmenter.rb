

require_relative 'dictionary'

#class StringSegmenter

  #Purpose: Take in a String comprised of words without spaces between them and return the separated words in an Array.
  #
  #Inputs: A String comprised of words without spaces between them.
  #
  #Returns: An Array comprised of the separated words.
  def segment_string(str)
   
    
    #Purpose: Initialize incidence variables
    #
    #Inputs: none
    #
    #Returns: 
      #array1 = An Array that contains the component words of the original String. 
      #@s = An Integer. The index of the start point of a test word.
      #@e = An Integer. The index of the end point of a test word.
      #@l = An Integer. The length of the string to be separated.
    def setup #initialize incidence variables
    array1 = [] #our word bank   
    @s = 0 #start of a test word
    @e = 0 #end of a test word
    @l = str.length
    end
  
    #Purpose: Generate potential words comprised of consecutive letters from a String.
    #
    #Inputs: A String comprised of words without spaces between them.
    #
    #Returns: String comprised of the letters between the start point and end point.
    def make_word_candidates
      while @e <= l 
      @word = str[@s..@e]#.join
      end
    end 
    
    #Purpose: See if the potential words match entries in a dictionary. Current dictionary is a stub.
    #
    #Inputs: Potential words in String form generated by the Method make_word_candidates.
    #
    #Returns: Return message "true" for a dictionary match, "false" if not.
    def validate_word_match
      if valid_word?(@word)
            return true
      else  return false 
      end#this should be returning true or false
    end

    #Purpose: Store validated word in Array1
    #
    #Inputs: The Return "true" from the Method validate_word_match.
    #
    #Returns: Array containing validated words.
    def bank_valid_word_match(yes)
      if yes == true
        array1 << @word
      else nil
      end
    end

    #Purpose: Reset start and end points to begin looking for next word.
    #
    #Inputs: The Return "true" from the Method validate_word_match.
    #
    #Return: Start and End points one step beyond the end of the last found word.
    def begin_find_next_word(stepup)
      if stepup == true
      @s = @e+1
      @e += 1
      else nil
      end
    end

    #Purpose: Iterate end point to generate a new potential word if the previous potential word is not a word in our dictionary.
    #
    #Inputs: The Return "false" from the Method validate_word_match.
    def not_a_match(no)
      if no == false
      @e += 1 
      else nil 
      end
    end  

    #Purpose: Order of operations for segmenting the string.
    #
    #Inputs: none
    #
    #Returns: An Array (array1) containing the separate words that comprised the original string.
    def build_array
      setup
      while @e <= l
        make_word_candidates
        validate_word_match
        bank_valid_word_match(validate_word_match)
        begin_find_next_word(make_word_candidates)
        not_a_match(make_word_candidates)
        return array1
      end
      #return array1
    end
    
  # def output
  #   return array1
  # end
  
  end#end of segment_string method

#end#end of class "StringSegmenter"

     # str =("fieldhorsepetal")
